[![logo](logo.png)](README.md "for developers")  

Пример простейшего сервера, который асинхронно обрабатывает TCP/UDP на базе epoll
--------------------------------------------------------------------------------
Сервер умеет принимать следующие команды:  
  - `/time` запрос текущей даты-времени в формате "2025-11-10 16:27:44"  
  - `/stats` запрос статистики (общее количество/подключенные в данный момент)  
  - `/shutdown` запрос на завершение работы сервера  
  - на прочие запросы сервер делает эхо-отражение  

Исходный код максимально простой, и не имеет зависимостей от внешних библиотек,  
за исключением стандартной библиотеки c++, и posix-api  

Главная идея асинхронного дизайна заключается в том, 
что у клиентов есть возможность обмениваться сообщениями с сервером, поддерживая длительное соединение, 
а у сервера, даже в рамках одного потока, есть возможность обрабатывать сразу множество клиентов. 
В этом серверу помогает особый механизм, который называется epoll  

Вообще, понятие "ассинхронность" можно определить по-разному, но если подвести общий знаменатель,
то можно сформулировать его таким образом: асинхронная работа - это работа в фоновом режиме. 
Т.е., иницировавший асинхронную задачу поток может не останавливаясь, продолжить делать что-то ещё полезное. 
При этом, за непосредственное выполнение задачи отвечает внешний по отношению к инициатору обработчик.  

Дизайн обработчика может быть реализован по разному.  
Например, можно переодически проверять статус завершения задачи.  
Или можно получать результат работы в виде эвентов, которые в свою очередь могут быть реализованы в виде callback.  

В случае epoll, за ожидание событий, связанных с сокетами, отвечает операционная система.  
А вот обработка события - это уже на усмотрение конкретного приложения.  
В рамках данного проекта, я решил сделать обработку запросов клиентов в отдельных потоках.  
Просто, что бы продемострировать устройство и принцип работы thread_pool  


Принцип действия epoll
---
epoll можно рассматривать как, своего рода, умный контейнер файловых дескрипторов, 
за которыми он умеет приглядывать. 
При добавлении дескриптора в epoll, можно указать какие события мы хотим отслеживать. 
Например: мы можем добавить дескриптор сокета в epoll, 
подписавшись на событие: "разбуди, когда в сокет придут данные для чтения".  

Отсюда довольно таки простая логика:  
  - при подключении нового клиента, добавляем его сокет в epoll на прослушку  
  - когда epoll уведомит о том, что клиент нам что-то написал,  
    читаем/обрабатывам запрос клиента,  
    и ждем следующего уведомления.  


Структура репозитория
---
Имеет вид:  
```
example_epoll
 |--- cmake            сценарий сборки cmake
 |--- make             сценарий сборки make
 |--- package          скрипт для создания DEB-пакета
 |--- systemd          скрипт для установки сервера в систему
 |--- client_tcp.cpp   пример TCP клиента
 |--- client_udp.cpp   пример UDP клиента
 |--- epoll.cpp
 |--- epoll.hpp        работа с epoll
 |--- protocol.cpp  
 |--- protocol.hpp     чтение/отправка сообщений
 |--- server.cpp       пример-иллюстрация сервера
  `-- tpool.hpp        thread_pool
```

Клонирование проекта:  
```
git clone "https://github.com/Kartonagnick/example_epoll"   
```

Сборка и тестовый запуск с помощью cmake:  
```
cd ./example_epoll/cmake
./cmake-all.sh
./launch.sh
```

Сборка и тестовый запуск с помощью make:  
```
cd ./example_epoll/make
./make-all.sh
./launch.sh
```

В результате сборки создаются три бинарника:  
  - kart-client_udp  
  - kart-client_tcp  
  - kart-server  

Скрипт `launch.sh` запускает бинарники каждый в своем отдельном терминале  
В качестве клиента можно так же использовать встроенные средства линукс.  
Например, можно использовать netcat:  

```bash
# сначала запускаем сервер
./example_epoll/kart-server

# теперь можно отправлять запросы
echo "hello"  | nc -w 1 127.0.0.1 1234
echo ""
echo "/stats" | nc -w 1 127.0.0.1 1234
echo ""
echo "/time"  | nc -w 1 127.0.0.1 1234
echo ""
echo "/shutdown" | nc -w 1 127.0.0.1 1234
echo ""
```

Что бы создать DEB-пакет, запускаем скрипт:  
```
cd ./example_epoll/package
./make_package.sh
```

Каталог размещения готового DEB-пакета: `./example_epoll/build/kart-package.deb`  
Установка DEB-пакета:  

```
# предполагается, что мы находимся 
# в каталоге: ./example_epoll/package
sudo apt install ../build/kart-package.deb 
```

После инсталяции, сервер будет расположен:  
```
./package/usr/bin/kart-server
```

Для де-инсталляции можно выполнить:  
```
sudo apt remove kart-server
```

Для установки демона в систему:  
```
cd ./example_epoll/systemd
./install_service.sh
```

Тестовые клиенты сначала по очереди отправляют запросы:  
  - `hello`: эхо-отражение: в ответ, сервер тоже пришлет hello  
  - `/time`: в ответ сервер пришлет текущую дату-время  
  - `/stats`: в ответ сервер пришлет статистику вида: `connected 3, total 3`  

А дальше клиенты будут случайным образом генерировать запросы.  
И так будет продолжаться до тех пор, 
пока кто нибудь из клиентов не сгенерирует запрос `/shutdown`  

Здесь нужно сделать пояснение:  
На этапе запуска сервера, в epoll добавляются 3 штуки основных файловых дескрипторов:  
  - дескриптор для добавления TCP-клиентов  
  - дескриптор для добавления UDP-клиентов  
  - дескриптор event - сигнал об окончании работы.  

Когда сервер получает от клиента сообщение `/shutdown`, то он пишет в `event`,  
что в свою очередь триггерит `epoll`, и так информация о событии `shutdown` доходит до потока,  
который обрабатывает события от `epoll_wait`, и он благополучно останавливается.  

После полной остановки сервера, все подключенные к нему клиенты отвалятся по дисконнекту.  
И если сервер был запущен в виде демона, то он так и будет находится в выключенном состоянии.  
И поэтому, что бы снова с ним поиграться, его нужно будет опять запустить.  

Для перезапуска демона и клиентов, можно использовать:  
```
cd ./example_epoll/systemd
./launch.sh
```
<br/>

